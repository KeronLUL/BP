@page "/"
@using System.Reflection
@using System.Text.RegularExpressions
@using System.Xml.XPath
@using Microsoft.AspNetCore.Components
@using Newtonsoft.Json
@using WebApp.Models
@using WebScraper.Json.Entities

@inject IJSRuntime JsRuntime

<h3>Configuration file builder</h3>

<style>
    h3 {
        font-weight: bold;
        text-align: center;
        margin-top: 20px;
        margin-bottom: 30px;
    }

    form {
        background-color: #f7f7f7;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    .form-group {
        margin-bottom: 20px;
    }
    
    .form-group .form-group-property {
        margin-top: 10px;
        margin-bottom: 10px;
        margin-left: 75px;
    }
    
    .form-group .form-group-property label {
            margin-top: 5px;
        }

    label {
        font-weight: bold;
        margin-bottom: 5px;
        margin-left: 5px;
    }

    .form-control {
        border-radius: 3px;
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
    }
    
    .form-control select {
        padding: 10px;
        border-radius: 3px;
        border: 1px solid #ccc;
        width: 100%;
        height: 40px;
     }

    .btn-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 20px;
        flex-wrap: wrap;
        text-align: center;
    }

    .btn-container button {
        margin: 0 5px;
    }
</style>

<EditForm EditContext="@editContext">
    <DataAnnotationsValidator />
    <ValidationSummary />
    
    <div class="form-group">
        <label for="configName">Configuration file name</label>
        <input type="text" id="configName" class="form-control" @bind="@configName"/>
    </div>
    
    <div class="form-group">
        <label for="url">URL</label>
        <input type="text" id="url" class="form-control" @bind="@config.Url"/>
    </div>
    
    <div class="form-group">
        <label for="loop">Loop</label>
        <input type="checkbox" id="loop" class="form-check-input" @bind="@config.Loop"/>
    </div>
    
    <div class="form-group">
        <label for="waitTime">Wait Time</label>
        <input type="number" id="waitTime" class="form-control" @bind="@config.WaitTime"/>
    </div>
    
    <div class="form-group">
    <label for="driver">Driver</label>
    <select class="form-control" id="driver" @bind="@config.Driver">
        <option value="">Select an option...</option>
        <option value="Firefox">Firefox</option>
        <option value="Chrome">Chrome</option>
        <option value="Safari">Safari</option>
    </select>
    </div>

    @foreach (var field in commandFields)
    {
        <div class="form-group">
            <label for="@field.Id">Command</label>
            <select id="@field.Id" class="form-control" @bind="@field.Name">
                <option value="">Select...</option>
                @foreach (var cmd in GetCommands())
                {
                    <option value="@cmd">@cmd</option>
                }
            </select>
            @{
                FillProperties(field);
            }
            <div class="form-group-property">
                @foreach (var property in field.PropertyFields!)
                {
                    <label for="@property.Id">@property.Key</label>
                    <input type="text" id="@property.Id" class="form-control" @bind="@property.Value"/>
                    <ValidationMessage For="() => property.Id" />
                }
            </div>
        </div>
    }

    <div class="btn-container">
        <button type="button" class="btn btn-primary mt-3" @onclick="AddFormField">Add command</button>
        <button type="button" class="btn btn-primary mt-3" @onclick="HandleValidSubmit">Save config</button>
    </div>
</EditForm>

@code {
    private string? configName { get; set; }
    private List<CommandField> commandFields = new();
    private Config config = new();
    private EditContext? editContext;
    private ValidationMessageStore? validationMessageStore;

    protected override void OnInitialized()
    {
        editContext = new EditContext(this);
        validationMessageStore = new ValidationMessageStore(editContext);
    }

    private void AddFormField()
    {
        commandFields.Add(new CommandField { Id = Guid.NewGuid().ToString(), Name = string.Empty, PropertyFields = new List<PropertyField>() });
    }

    private static void FillProperties(CommandField command)
    {
        if (command.PropertyFields!.Count == 0)
        {
            foreach (var property in GetProperties(command.Name))
            {
                command.PropertyFields.Add( new PropertyField { Id = Guid.NewGuid().ToString(), Key = property.Name, Value = string.Empty });
            }
        }
    }

    private static List<string> GetCommands()
    {
        return WebScraper.CommandServices.GetCommandsNames();
    }

    private static IEnumerable<PropertyInfo> GetProperties(string? name)
    {
        return WebScraper.CommandServices.GetProperties(name);
    }

    private bool Validate(CommandField command, PropertyField property)
    {
        if (string.IsNullOrWhiteSpace(property.Value))
        {
            validationMessageStore!.Add(editContext!.Field(property.Id!), $@"Field value of property {property.Key} of command {command.Name} cannot be empty");
            editContext.NotifyValidationStateChanged();
            return false;
        }
        if (property.Key == "Time")
        {
            if (!int.TryParse(property.Value, out _))
            {
                validationMessageStore!.Add(editContext!.Field(property.Id!), $@"Field value of property {property.Key} of command {command.Name} must be a number");
                editContext.NotifyValidationStateChanged();
                return false;
            }
        }else if(property.Key is "Path" or "Attribute") // fix
        {
            if (!Regex.IsMatch(property.Value, @"^(/?[\w-]+(:?/[\w-]+)*)*(\[@?\w+(\s*=\s*('.*?'|"".+?""|\w+))?\])*$"))
            {
                validationMessageStore!.Add(editContext!.Field(config.Url!), $@"{config.Url} is not valid URL");
                editContext.NotifyValidationStateChanged();
                return false;
            }
            
        }
        return true;
    }

    private bool ValidateUrl(string? url)
    {
        if(string.IsNullOrWhiteSpace(config.Url))
        {
            config.Url = string.Empty;
            validationMessageStore!.Add(editContext!.Field(config.Url!), $@"URL field cannot be empty");
            editContext.NotifyValidationStateChanged();
            return false;
        }
        if (!Regex.IsMatch(url!, @"^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)$"))
        {
            validationMessageStore!.Add(editContext!.Field(config.Url!), $@"{config.Url} is not valid URL");
            editContext.NotifyValidationStateChanged();
            return false;
        }
        return true;
    }

    private void HandleValidSubmit()
    {
        validationMessageStore!.Clear();
        editContext!.NotifyValidationStateChanged();

        if (!ValidateUrl(config.Url!)) return;
        
        config.Commands = new List<CommandConfig>();
        foreach (var command in commandFields)
        {
            config.Commands.Add(new CommandConfig() { Name = command.Name, Args = new Dictionary<string, object>()});
            foreach (var property in command.PropertyFields!)
            {
                if (!Validate(command, property))
                {
                    config.Commands.Clear();
                    return;
                }
                if (property.Key == "Time")
                {
                    int.TryParse(property.Value, out var value);
                    config.Commands.Last().Args!.Add(property.Key!, value);
                }
                else
                {
                    config.Commands.Last().Args!.Add(property.Key!, property.Value!);
                }
            }
        }
        DownloadFile();
    }

    private async void DownloadFile()
    {
        await JsRuntime.InvokeAsync<object>("saveFile", configName != null ? $"{configName}.json" : "config.json", JsonConvert.SerializeObject(config, Formatting.Indented));
    }
}